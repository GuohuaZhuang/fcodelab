B-trees are balance search trees designed to work well on disks or other direct-access secondary storage advices. B-trees are similar to red-black trees, but they are better at minimizing disk I/O operations. Many database systems use B-trees, or variants of B-Trees, to store information.
B-Trees differ from red-black trees in that B-Tree nodes may have many chlidren, from a few to thousands. That is, the "branching factor" of a B-tree can be quite large, although it useually depends on characteristics of the disk unit used. B-trees differ from red-black trees in that B-tree nodes may have many children, from a few to thousands. That is, the "branching factor" of a B-tree can be quite large, although it useually depends on characteristics of the disk unit used. B-trees exact height of a B-tree can be considerably less than that of a red-black tree, however, because its branching factor.

pseudocode

B-TREE-SEARCH(x, k) {
	i = 1;
	while (i <= x.n and k > x.key[i]) {
		i = i + 1;
	}
	if (i <= x.n and k == x.key[i]) {
		return (x, i);
	} else if (x.leaf) {
		return NIL;
	} else {
		DISK-READ(x.c[i]);
		return B-TREE-SEARCH(x.c[i], k);
	}
}

B-TREE-CREATE(T) {
	x = ALLOCATE-NODE();
	x.leaf = TRUE;
	x.n = 0;
	DISK-WRITE(x);
	T.root = x;
}

Inserting a key into a B-Tree is significantly more complicated than inserting a key into a binary search tree. As with binary search trees, we search for the leaf position at which to insert the new key. With a B-Tree, however, we cannot simply create a new leaf node and insert in, as the resulting tree would fail to be a valid B-tree.

B-TREE-SPLIT-CHLID(x, i) {
	z = ALLOCATE-NODE();
	y = x.c[i];
	z.leaf = y.leaf;
	z.n = t - 1;
	for (j = 1; j <= t - 1; j ++) {
		z.key[j] = y.key[j+t];
	}
	if (!y.leaf) {
		for (j = 1; j <= t; j ++) {
			z.c[j] = y.c[j+t];
		}
	}
	y.n = t - 1;
	for (j = x.n + 1; j >= i + 1; j --) {
		x.c[j+1] = x.c[j];
	}
	x.c[i+1] = z;
	for (j = x.n; j >= i; j --) {
		x.key[j+1] = x.key[j];
	}
	x.key[i] = y.key[t];
	x.n = x.n + 1;
	DISK-WRITE(y);
	DISK-WRITE(z);
	DISK-WRITE(x);
}

B-TREE-INSERT(T, k) {
	r = T.root;
	if (r.n == 2t - 1) {
		s = ALLOCATE-NODE();
		T.root = s;
		s.leaf = FALSE;
		s.n = 0;
		s.c[1] = r;
		B-TREE-INSERT-NONFULL(s, k);
	} else {
		B-TREE-INSERT-NONFULL(r, k);
	}
}

B-TREE-INSERT-NONFULL(x, k) {
	i = x.n;
	if (x.leaf) {
		while (i >= 1 && k < x.key[i]) {
			x.key[i+1] = x.key[i];
			i = i - 1;
		}
		x.key[i+1] = k;
		x.n = x.n + 1;
		DISK-WRITE(x);
	} else {
		while (i >= 1 && k < x.key[i]) {
			i = i - 1;
		}
		i = i + 1;
		DISK-READ(x.c[i]);
		if (x.c[i].n == 2t - 1) {
			B-TREE-SPLIT-CHILD(x, i);
			if (k > x.key[i]) {
				i = i + 1;
			}
		}
		B-TREE-INSERT-NONFULL(x.c[i], k);
	}
}

