<!DOCTYPE>
<html>
<head>
	<title>lianliankan implement in javascript</title>
	<style type="text/css" media="screen">
	body {
		margin: 0px;
	}
	.table_panel {
		border: 0px;
		padding: 0px;
		margin: 0px;
		border-collapse: collapse;
	}
	.table_panel tr {
		padding: 0px;
		margin: 0px;
		border: 0px;
	}
	.table_panel td { 
		padding: 0px;
		margin: 0px;
		border: 0px;
		background: pink;
		width: 38px;
		height: 38px;
		text-align: center;
		vertical-align: middle;
	}
	.table_panel img {
		padding: 0px;
		margin: 0px;
		width: 30px;
		height: 30px;
	}
	.canvas_path {
		border: 0px;
		position: absolute;
		z-index: 0;
		top: 0;
		left: 0;
		display: none;
		background: rgba(255, 0, 0, 0.0);
	}
	</style>
	<script type="text/javascript" charset="utf-8">
	// element struct
	function ELEMENT(flag) {
		this.flag = flag;
	}
	function POINT(x, y) {
		this.x = x; this.y = y;
	}
	if (typeof NAVIGATE_TYPE == 'undefined') {
		var NAVIGATE_TYPE = { NONE: 0, TOP: 1, BOTTOM: 2, LEFT: 3, RIGHT: 4 }
	}
	// global variables
	var ROWS = 10;
	var COLUMNS = 12;
	var MAX_INT = Math.pow(2, 53);
	var g_elements = null;
	var g_crossing = null;
	var g_distance = null;
	var g_navigate = null;
	var g_preelement = null;
	var g_curelement = null;
	var panel = null; 
	// init variables struct
	function init_struct() {
		var arrayrows = ROWS+1, arraycolumns = COLUMNS+1;
		g_elements = new Array(ROWS+2);
		for (var i = 0; i <= arrayrows; i ++) {
			g_elements[i] = new Array(COLUMNS+2);
			for (var j = 0; j <= arraycolumns; j ++) {
				if (0 == i || 0 == j || arrayrows == i || arraycolumns == j) {
					g_elements[i][j] = new ELEMENT(0);
					continue;
				}
				g_elements[i][j] = new ELEMENT(Math.floor(Math.random()*15)+1);
			}
		}
	}
	function init_crossing_and_distance() {
		g_crossing = null; g_distance = null; g_navigate = null;
		var arrayrows = ROWS+1, arraycolumns = COLUMNS+1;
		g_crossing = new Array(ROWS+2);
		g_distance = new Array(ROWS+2);
		g_navigate = new Array(ROWS+2);
		for (var i = 0; i <= arrayrows; i ++) {
			g_crossing[i] = new Array(COLUMNS+2);
			g_distance[i] = new Array(COLUMNS+2);
			g_navigate[i] = new Array(COLUMNS+2);
			for (var j = 0; j <= arraycolumns; j ++) {
				g_crossing[i][j] = MAX_INT;
				g_distance[i][j] = MAX_INT;
				g_navigate[i][j] = NAVIGATE_TYPE.NONE;
			}
		}
	}
	// init table
	function init_table() {
		panel = document.getElementById("panel");
		var arrayrows = ROWS+1, arraycolumns = COLUMNS+1;
		for (var i = 0; i <= arrayrows; i ++) {
			var line = panel.insertRow(0);
			for (var j = 0; j <= arraycolumns; j ++) {
				var cell = line.insertCell(0);
			}
		}
		for (i = 1; i <= ROWS; i ++) {
			for (j = 1; j <= COLUMNS; j ++) {
				panel.rows[i].cells[j].innerHTML = 
					'<img src="./assets/' + g_elements[i][j].flag + '.gif" />';
			}
		}
		panel.onclick = elementclick_handler;
	}
	function elementclick_handler(event) {
		event = event ? event : window.event;
		var cellimg = event.srcElement ? event.srcElement : event.target;
		if ('IMG' != cellimg.tagName) { return; }
		cellimg.style.border = 'solid red 3px';
		var cell = cellimg.parentNode;
		g_preelement = g_curelement;
		g_curelement = new POINT(cell.parentNode.rowIndex, cell.cellIndex);
		linkup();
	}
	function cleanup(f) {
		if (!f) {
			if (null != g_preelement) {
				panel.rows[g_preelement.x].cells[g_preelement.y].childNodes[0]
					.style.border = '';
			}
			if (null != g_curelement) {
				panel.rows[g_curelement.x].cells[g_curelement.y].childNodes[0]
					.style.border = '';
			}
		} else {
			panel.rows[g_preelement.x].cells[g_preelement.y].innerHTML = "";
			panel.rows[g_curelement.x].cells[g_curelement.y].innerHTML = "";
			g_elements[g_preelement.x][g_preelement.y].flag = 0;
			g_elements[g_curelement.x][g_curelement.y].flag = 0;
		}
		g_preelement = null;
		g_curelement = null;
	}
	function linkup() {
		if (null == g_preelement || null == g_curelement) {
			return ;
		}
		var f = 0;
		do {
			if (g_elements[g_preelement.x][g_preelement.y].flag
					!= g_elements[g_curelement.x][g_curelement.y].flag) {
				f = 0; break;
			}
			init_crossing_and_distance();
			if (findpath(g_preelement, g_curelement, 0, 0)) {
				drawpath();
				f = 1; break;
			}
		} while (0);
		cleanup(f);
	}
	function point_equal(p, q) {
		return (p.x == q.x && p.y == q.y);
	}
	function pointxy_equal(x, y, q) {
		return (x == q.x && y == q.y);
	}
	function update_minimum_path(x, y, crossing, distance, navigate) {
		if (g_crossing[x][y] > crossing 
			|| (g_crossing[x][y] == crossing && g_distance[x][y] > distance)) {
			g_crossing[x][y] = crossing;
			g_distance[x][y] = distance;
			g_navigate[x][y] = navigate;
			return true;
		}
		return false;
	}
	function drawpath() {
		var p1 = null;
		var p2 = g_curelement;
		var paths = new Array();
		var navigate = NAVIGATE_TYPE.NONE;
		do {
			navigate = g_navigate[p2.x][p2.y];
			g_navigate[p2.x][p2.y] = NAVIGATE_TYPE.NONE;
			switch (navigate) {
				case NAVIGATE_TYPE.TOP:
					p1 = new POINT(p2.x+1, p2.y);
					break;
				case NAVIGATE_TYPE.BOTTOM:
					p1 = new POINT(p2.x-1, p2.y);
					break;
				case NAVIGATE_TYPE.LEFT:
					p1 = new POINT(p2.x, p2.y+1);
					break;
				case NAVIGATE_TYPE.RIGHT:
					p1 = new POINT(p2.x, p2.y-1);
					break;
				default:
			}
			paths.push(p1); paths.push(p2); p2 = p1;
		} while (navigate != NAVIGATE_TYPE.NONE);
		drawline(paths);
		setTimeout(clearcanvas, 500);
	}
	function drawline(paths) {
		var canvas = document.getElementById("path");
		canvas.width = panel.offsetWidth;
		canvas.height = panel.offsetHeight;
		canvas.top = panel.offsetTop;
		canvas.left = panel.offsetLeft;
		var context = canvas.getContext("2d");
		context.strokeStyle = "#FF0000";
		context.lineWidth = 3;
		context.beginPath();
		while (paths.length > 0) {
			var p = paths.pop(); var q = paths.pop();
			var Ax = panel.rows[p.x].cells[p.y].offsetLeft + panel.rows[p.x].cells[p.y].offsetWidth/2;
			var Ay = panel.rows[p.x].cells[p.y].offsetTop + panel.rows[p.x].cells[p.y].offsetHeight/2;
			var Bx = panel.rows[q.x].cells[q.y].offsetLeft + panel.rows[q.x].cells[q.y].offsetWidth/2;
			var By = panel.rows[q.x].cells[q.y].offsetTop + panel.rows[q.x].cells[q.y].offsetHeight/2;
			context.moveTo(Ax, Ay);
			context.lineTo(Bx, By);
		}
		context.stroke();
		context.closePath();
		canvas.style.display = 'block';
	}
	function clearcanvas() {
		var canvas = document.getElementById("path");
		var context = canvas.getContext("2d");
		context.clearRect(0, 0, canvas.width, canvas.height);
		context.restore();
		canvas.style.display = 'none';
	}
	function findpath(p, q, crossing, distance) {
		if (crossing > 2) return false;
		var S = [];
		var x = p.x, y = p.y;
		var f = 0;
		var arrayrows = ROWS+1, arraycolumns = COLUMNS+1;
		var isupdate = false;
		update_minimum_path(x, y, crossing, distance, NAVIGATE_TYPE.NONE);
		f = 0; x = p.x-1; y = p.y; while (x >= 0 && 0 == f) {
			if (g_elements[x][y].flag > 0) { f = 1; }
			isupdate = update_minimum_path(x, y, crossing, distance+(p.x-x), NAVIGATE_TYPE.TOP);
			if (!isupdate) { break; }
			if (pointxy_equal(x, y, q)) { return true; }
			if (!f) S.push(new POINT(x,y));
			x --;
		}
		f = 0; x = p.x+1; y = p.y; while (x <= arrayrows && 0 == f) {
			if (g_elements[x][y].flag > 0) { f = 1; }
			isupdate = update_minimum_path(x, y, crossing, distance+(x-p.x), NAVIGATE_TYPE.BOTTOM);
			if (!isupdate) { break; }
			if (pointxy_equal(x, y, q)) { return true; }
			if (!f) S.push(new POINT(x,y));
			x ++;
		}
		f = 0; x = p.x; y = p.y-1; while (y >= 0 && 0 == f) {
			if (g_elements[x][y].flag > 0) { f = 1; }
			isupdate = update_minimum_path(x, y, crossing, distance+(p.y-y), NAVIGATE_TYPE.LEFT);
			if (!isupdate) { break; }
			if (pointxy_equal(x, y, q)) { return true; }
			if (!f) S.push(new POINT(x,y));
			y --;
		}
		f = 0; x = p.x; y = p.y+1; while (y <= arraycolumns && 0 == f) {
			if (g_elements[x][y].flag > 0) { f = 1; }
			isupdate = update_minimum_path(x, y, crossing, distance+(y-p.y), NAVIGATE_TYPE.RIGHT);
			if (!isupdate) { break; }
			if (pointxy_equal(x, y, q)) { return true; }
			if (!f) S.push(new POINT(x,y));
			y ++;
		}
		while (S.length > 0) {
			var point = S.shift();
			if (findpath(point, q, crossing+1, g_distance[point.x][point.y])) {
				return true;
			}
		}
		return false;
	}
	function init() {
		init_struct();
		init_table();
	}
	</script>
</head>

<body onload="init()">
	<canvas id="path" class="canvas_path">
	Your browser does not support the canvas element.
	</canvas>
	<table id="panel" class="table_panel"></table>
</body>
</html>
